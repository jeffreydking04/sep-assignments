Before we get to the actual written assignment, which appears to be part 2 of the assignment, let us first talk about the hashclass.rb.

First, I did not understand that what was being stored in the underlying hash array of a outward facing hash was a instance of a class.  Now it makes complete sense, but I had the impression that the value was what was stored in the internal array, and when it was accessed, the key requested was sent through the hash function, an index was returned, and the array was accessed and the value returned.  Upon further reflection, I suppose I should have understood that the key also had to be stored.  So I struggled hard with that until I figured out that hash_item was not supposed to be the hash function.  I see now that the assignment does specifically state that I need to store the key and value for each node in the array.

Secondly, the assignment stipulates that we need to write our own hashing function, but the tests are based off of using the ascii value of the passed string.  My own hashing function, which I just used a modified Bernstein from the Eternally Confuzzled website (but hey, that article gave me a glimpse into hash functions--nice piece), creates different hash codes and thus different indices, thus the tests do not work.  But the tests that do not specify index values do work.

Except for one:  The sixth test wants to make sure that the array gets resized if there is a collison, which the 7th test also tested implicitly before I implemented a different hashing function.  But the test does not actually create a collision, unless I misunderstand it:  It is really just a reassignment and there is no need to resize the array for a reassignment.

So my code does not pass specs.  I chose to implement a hashing function which does not pass specs and also I chose to ignore the sixth test, because automatically resizing on reassignment would be inefficient.

2. As for doubling the size of the array, this will increase the likelihood of future collisions because a multiple of the previous array size is far more likely to produce the same remainder (and thus the same index, so that a collision occurs again) than doubling, then moving up to the nearest prime.  Resizing the array takes both time and space and should be avoided if the cost of avoiding it is less than the cost of resizing.  Even simply adding 1 to the resize would dramatically reduce recurrent collisions.